#!/bin/sh

# IP
function check_ip() {
    local IP=$1
    VALID_CHECK=$(echo $IP|awk -F. '$1<=255&&$2<=255&&$3<=255&&$4<=255{print "yes"}')
    if echo $IP|grep -E "^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$" >/dev/null; then
        if [ $VALID_CHECK == "yes" ]; then
            return 0
        else
            echo "IP $IP 错误!"
            return 1
        fi
    else
        echo "IP 错误!"
        return 1
    fi
}
while true; do
    read -p "请输入Tars服务器IP: " local_ip
    check_ip $local_ip
    [ $? -eq 0 ] && break
done

# do_type
function check_do_type() {
	local do_type=$1
	if [ "$do_type" != "install_client" ] && [ "$do_type" != "install_server" ] && [ "$do_type" != "update_client" ] && [ "$do_type" != "update_server" ];then
		echo '动作不在给定范围内(install_client/install_server/update_client/update_server)！'
        	return 1
	fi
}
while true; do
    read -p "请输入动作(install_client/install_server/update_client/update_server): " do_type
    check_do_type $do_type
    [ $? -eq 0 ] && break
done


# 服务端配置
if [ "$do_type" == "install_server" ];then

	# AppName
	function checkAppName() {
		local AppName=$1
		if [ ! -n "$AppName" ];then
			echo 'AppName错误！'
	        	return 1
		fi
	}
	while true; do
	    read -p "请输入AppName: " AppName
	    checkAppName $AppName
	    [ $? -eq 0 ] && break
	done

	# ServerName
	function checkServerName() {
		local ServerName=$1
		if [ ! -n "$ServerName" ];then
			echo 'ServerName错误！'
	        	return 1
		fi
	}
	while true; do
	    read -p "请输入ServerName: " ServerName
	    checkServerName $ServerName
	    [ $? -eq 0 ] && break
	done

	# ObjName
	function checkObjName() {
		local ObjName=$1
		if [ ! -n "$ObjName" ];then
			echo 'ObjName错误！'
	        	return 1
		fi
	}
	while true; do
	    read -p "请输入ObjName: " ObjName
	    checkObjName $ObjName
	    [ $? -eq 0 ] && break
	done

	# impl.tars
	if [ ! -f "impl.tars" ];then
		echo "请先定义impl.tars文件！"
		exit 0
	fi

	# appName 首字母转大写
	appName=`echo "$AppName" | awk '{for (i=1;i<=NF;i++)printf toupper(substr($i,0,1))substr($i,2,length($i))" ";printf "\n"}' `
	appName=`echo "$appName" | sed 's/ //g'`
	# ServerName 首字母转大写
	serverName=`echo "$ServerName" | awk '{for (i=1;i<=NF;i++)printf toupper(substr($i,0,1))substr($i,2,length($i))" ";printf "\n"}' `
	serverName=`echo "$serverName" | sed 's/ //g'`
	# ObjName 首字母转大写
	objName=`echo "$ObjName" | awk '{for (i=1;i<=NF;i++)printf toupper(substr($i,0,1))substr($i,2,length($i))" ";printf "\n"}' `
	objName=`echo "$objName" | sed 's/ //g'`

	# 获取impl.tars中类的名字
	class_name=`cat impl.tars | grep interface | awk '{print $NF}' | grep -Eo "\<[[:alnum:]_]+\>"`

	if [ ! -n "$class_name" ];then
		echo 'impl.tar文件内容错误'
		exit 0
	fi

	mkdir ${appName}
	mkdir -p ${appName}/src
	mkdir -p ${appName}/script
	mkdir -p ${appName}/tars
	mkdir -p ${appName}/src/service
	mkdir -p ${appName}/src/model
	mkdir -p ${appName}/src/traits
	mkdir -p ${appName}/src/middleware
	mkdir -p ${appName}/src/common
	mkdir -p ${appName}/src/libs

	# 客户端tars文件不是必须，如果需要调用某个服务使用script中脚本生成即可
	cp impl.tars ./${appName}/tars/${appName}Service.tars
	with_servant=true
	namespace=${serverName}
	proto_php_name="tars.proto.php"
	proto_php_path=${appName}"/tars/"$proto_php_name
	touch $proto_php_path
cat>$proto_php_path<<EOF
<?php
return array(
    'appName' => '${appName}',
    'serverName' => '${serverName}',//发布服务器时需要注意使用此名称
    'objName' => '${objName}',
    'withServant' => ${with_servant}, //决定是服务端,还是客户端的自动生成
    'tarsFiles' => array(
        './${appName}Service.tars',
    ),
    'dstPath' => '../src/servant',
    'namespacePrefix' => '${namespace}\servant',
);
EOF

composer_json=${appName}"/src/composer.json"
touch $composer_json

cat>$composer_json<<EOF
{
    "name" : "${appName}",
    "description": "${appName}",
    "require": {
        "phptars/tars-server": "~0.1",
        "phptars/tars-deploy": "~0.1",
        "phptars/tars2php": "~0.1",
        "phptars/tars-log": "~0.1",
        "ext-zip" : ">=0.0.1",
        "catfan/medoo": "^1.5",
        "joshcam/mysqli-database-class": "^2.9"
    },
    "autoload": {
        "psr-4": {
            "${namespace}\\\" : "./"
        }
    },
    "minimum-stability": "stable",
    "scripts" : {
        "deploy" : "\\\Tars\\\deploy\\\Deploy::run"
    }
}
EOF

index_php=${appName}"/src/index.php"
touch $index_php

cat>$index_php<<EOF
<?php
require_once __DIR__.'/vendor/autoload.php';
use \Tars\cmd\Command;
use ${namespace}\libs\Loader;

//php tarsCmd.php  conf restart
\$config_path = \$argv[1];
\$pos = strpos(\$config_path, '--config=');

\$config_path = substr(\$config_path, $pos + 9);

\$cmd = strtolower(\$argv[2]);
//初始化数据库
if(\$cmd=='start'){
    Loader::getLoader();
}

\$class = new Command(\$cmd, \$config_path);
\$class->run();
EOF

mkdir ${appName}/src/servant

tars2php_sh=${appName}"/script/tars2php.sh"
touch $tars2php_sh

cat>$tars2php_sh<<EOF
#!/bin/bash
cd ../tars/
php ../src/vendor/phptars/tars2php/src/tars2php.php ./${proto_php_name}
EOF
chmod u+x ${tars2php_sh}

cd ${appName}/src/
composer install

cd ../tars/
php ../src/vendor/phptars/tars2php/src/tars2php.php ./${proto_php_name}

cd ../src/servant/${appName}/${serverName}/${objName}
base_implace_class_file_name=`ls *php`
if [ ! -n "$base_implace_class_file_name" ];then
	echo "[ ERROR ] : impl文件错误，未生成接口文件，请删除${appName}重试！"
	exit 0
fi

base_implace_class_file_name=`echo $base_implace_class_file_name | sed 's/.php//g'`

implace_class_file_name=`echo $base_implace_class_file_name | sed 's/$/Impl/g'`

cd ../../../../..

services_php="src/services.php"
touch $services_php

mkdir -p src/impl
implace_class_file_path="src/impl/${implace_class_file_name}.php"
touch $implace_class_file_path

cat>$implace_class_file_path<<EOF
<?php
namespace ${namespace}\Impl;

use ${namespace}\servant\\${appName}\\${serverName}\\${objName}\\${base_implace_class_file_name};

class ${implace_class_file_name} implements ${base_implace_class_file_name}
{
    public function functionName($param)
    {
        return 'test ok !!';
    }
}
?>

EOF

cat>$services_php<<EOF
<?php
return array(
	'home-api'=> '\\${namespace}\servant\\${appName}\\${serverName}\\${objName}\\${base_implace_class_file_name}',
	'home-class'=> '\\${namespace}\impl\\${implace_class_file_name}', 
	'namespaceName'  => '${namespace}\\\'
);

EOF




mkdir /src/conf
ENVConf_php="/src/conf/ENVConf.php"
touch $ENVConf_php

cat>$ENVConf_php<<EOF
<?php

namespace ${namespace}\conf;

class ENVConf
{
    public static \$locator = 'tars.tarsregistry.QueryObj@tcp -h ${local_ip} -p 17890';

    public static \$socketMode = 3;

    public static function getTarsConf()
    {
        \$table = \$_SERVER->table;
        \$result = \$table->get('tars:php:tarsConf');
        \$tarsConf = unserialize(\$result['tarsConfig']);

        return \$tarsConf;
    }
}
EOF

echo "SUCCESS"
echo "请在impl下写入代码逻辑"
echo "src下执行 composer run-script deploy 打包"

fi







#--------------------------------------------------------------------------------------------------------------------------------------------








# 客户端配置
if [ "$do_type" == "install_client" ];then

	# AppName
	function checkAppName() {
		local AppName=$1
		if [ ! -n "$AppName" ];then
			echo 'AppName错误！'
	        	return 1
		fi
	}
	while true; do
	    read -p "请输入AppName: " AppName
	    checkAppName $AppName
	    [ $? -eq 0 ] && break
	done

	# ServerName
	function checkServerName() {
		local ServerName=$1
		if [ ! -n "$ServerName" ];then
			echo 'ServerName错误！'
	        	return 1
		fi
	}
	while true; do
	    read -p "请输入ServerName: " ServerName
	    checkServerName $ServerName
	    [ $? -eq 0 ] && break
	done

	# ObjName
	function checkObjName() {
		local ObjName=$1
		if [ ! -n "$ObjName" ];then
			echo 'ObjName错误！'
	        	return 1
		fi
	}
	while true; do
	    read -p "请输入ObjName: " ObjName
	    checkObjName $ObjName
	    [ $? -eq 0 ] && break
	done

	# appName 首字母转大写
	appName=`echo "$AppName" | awk '{for (i=1;i<=NF;i++)printf toupper(substr($i,0,1))substr($i,2,length($i))" ";printf "\n"}' `
	appName=`echo "$appName" | sed 's/ //g'`
	# ServerName 首字母转大写
	serverName=`echo "$ServerName" | awk '{for (i=1;i<=NF;i++)printf toupper(substr($i,0,1))substr($i,2,length($i))" ";printf "\n"}' `
	serverName=`echo "$serverName" | sed 's/ //g'`
	# ObjName 首字母转大写
	objName=`echo "$ObjName" | awk '{for (i=1;i<=NF;i++)printf toupper(substr($i,0,1))substr($i,2,length($i))" ";printf "\n"}' `
	objName=`echo "$objName" | sed 's/ //g'`

	mkdir ${appName}
	mkdir -p ${appName}/src
	mkdir -p ${appName}/script
	mkdir -p ${appName}/tars
	mkdir -p ${appName}/src/service
	mkdir -p ${appName}/src/model
	mkdir -p ${appName}/src/traits
	mkdir -p ${appName}/src/middleware
	mkdir -p ${appName}/src/controller
	mkdir -p ${appName}/src/common
	mkdir -p ${appName}/src/libs

	namespace=${serverName}
	client_proto_php_path=${appName}"/tars/tars.proto.php"
	touch $client_proto_php_path
cat>$client_proto_php_path<<EOF
<?php
return array(
    'appName' => '${appName}',
    'serverName' => '${serverName}',//发布服务器时需要注意使用此名称
    'objName' => '${objName}',
);

EOF

composer_json=${appName}"/src/composer.json"
touch $composer_json

cat>$composer_json<<EOF
{
    "name" : "${appName}",
    "description": "${appName}",
    "require": {
        "phptars/tars-server": "~0.1",
        "phptars/tars-deploy": "~0.1",
        "phptars/tars2php": "~0.1",
        "phptars/tars-log": "~0.1",
        "ext-zip" : ">=0.0.1",
        "catfan/medoo": "^1.5",
        "joshcam/mysqli-database-class": "^2.9"
    },
    "autoload": {
        "psr-4": {
            "${namespace}\\\" : "./"
        }
    },
    "minimum-stability": "stable",
    "scripts" : {
        "deploy" : "\\\Tars\\\deploy\\\Deploy::run"
    }
}
EOF

index_php=${appName}"/src/index.php"
touch $index_php

cat>$index_php<<EOF
<?php
require_once __DIR__.'/vendor/autoload.php';
use \Tars\cmd\Command;
use ${namespace}\libs\Loader;

//php tarsCmd.php  conf restart
\$config_path = \$argv[1];
\$pos = strpos(\$config_path, '--config=');

\$config_path = substr(\$config_path, $pos + 9);

\$cmd = strtolower(\$argv[2]);
//初始化数据库
if(\$cmd=='start'){
    Loader::getLoader();
}

\$class = new Command(\$cmd, \$config_path);
\$class->run();
EOF

mkdir ${appName}/src/servant

cd ${appName}/src/
composer install

cd ../
tars2php_sh="script/tars2php.sh"
touch $tars2php_sh
cat>$tars2php_sh<<EOF
#!/bin/bash
set -e
function checkServantName() {
    local ServantName=\$1
    if [ ! -n "\$ServantName" ];then
        echo 'ServantName错误！'
        return 1
    fi
    if [ ! -d "../tars/\${ServantName}" ];then
        echo "\${ServantName}文件夹不存在！"
        exit 0
    fi
    if [ ! -f "../tars/\${ServantName}/\${ServantName}.tars" ];then
        echo "tars/\${ServantName}/\${ServantName}.tars文件不存在！"
        exit 0
    fi
    if [ ! -f "../tars/\${ServantName}/tars.proto.php" ];then
        echo "tars/\${ServantName}/tars.proto.php文件不存在！"
        exit 0
    fi
}
while true; do
    read -p "请输入tars中服务文件夹名称[文件夹名称须与.tars文件名称相同,文件下须有tars.proto.php文件，注意.tars中配置]: " ServantName
    checkServantName \$ServantName
    [ \$? -eq 0 ] && break
done
cd ../tars/
php ../src/vendor/phptars/tars2php/src/tars2php.php ./\${ServantName}/tars.proto.php
EOF
chmod u+x ${tars2php_sh}
#cd tars/
#php ../src/vendor/phptars/tars2php/src/tars2php.php ./${proto_php_name}



services_php="src/services.php"
touch $services_php

cat>$services_php<<EOF
<?php
return array(
	'namespaceName' => '${namespace}\\\'
);
EOF

mkdir -p src/component
component_controller_path="src/component/Controller.php"
touch $component_controller_path

cat>$component_controller_path<<EOF
<?php
namespace ${namespace}\component;

use Tars\core\Request;
use Tars\core\Response;

class Controller
{
    protected \$request;
    protected \$response;

    public function __construct(Request \$request, Response \$response)
    {
        // 验证cookie、get参数、post参数、文件上传

        \$this->request = \$request;
        \$this->response = \$response;
    }

    public function getResponse()
    {
        return \$this->response;
    }

    public function getRequest()
    {
        return \$this->request;
    }

    public function cookie(\$key, \$value = '', \$expire = 0, \$path = '/', \$domain = '', \$secure = false, \$httponly = false)
    {
        \$this->response->cookie(\$key, \$value, \$expire, \$path, \$domain, \$secure, \$httponly);
    }

    // 给客户端发送数据
    public function sendRaw(\$result)
    {
        \$this->response->send(\$result);
    }

    public function header(\$key, \$value)
    {
        \$this->response->header(\$key, \$value);
    }

    public function status(\$http_status_code)
    {
        \$this->response->status(\$http_status_code);
    }
}

EOF

index_controller_path="src/controller/${appName}Controller.php"
touch $index_controller_path

cat>$index_controller_path<<EOF
<?php

namespace ${namespace}\controller;

use Tars\core\Request;
use Tars\core\Response;
use ${namespace}\component\Controller;
use ${namespace}\conf\ENVConf;
use Tars\client\CommunicatorConfig;

class ${appName}Controller extends Controller
{
    //public \$servant;
    public function __construct(Request \$request, Response \$response)
    {
        parent::__construct(\$request, \$response);
        //\$config = new CommunicatorConfig();
        //\$config->setLocator(ENVConf::\$locator);
        //\$config->setModuleName('${appName}.${namespace}');
        //\$config->setSocketMode(3);
        //\$this->servant = new ${base_implace_class_file_name}(\$config);
    }

    /*
    curl "192.168.91.53:20002/Index/hello?a=b" -i
    public function actionFunctionName()
    {
        //\$result=\$this->servant->functionName('param');
        //\$this->sendRaw('result:' . \$result);
    }
    */
}

EOF


mkdir src/conf
ENVConf_php="src/conf/ENVConf.php"
touch $ENVConf_php

cat>$ENVConf_php<<EOF
<?php

namespace ${namespace}\conf;

class ENVConf
{
    public static \$locator = 'tars.tarsregistry.QueryObj@tcp -h ${local_ip} -p 17890';

    public static \$socketMode = 3;

    public static function getTarsConf()
    {
        \$table = \$_SERVER->table;
        \$result = \$table->get('tars:php:tarsConf');
        \$tarsConf = unserialize(\$result['tarsConfig']);

        return \$tarsConf;
    }
}
EOF

echo "SUCCESS"
echo "请在controller下写入代码逻辑"
echo "src下执行 composer run-script deploy 打包"

fi
