# 锁

## 互斥锁

保证资源数据在任意时刻只有一个线程处理该对象；

如果一个线程获得了该资源的使用权，并将其加锁后，再解锁前其他线程想获取该资源的使用和加锁都将会被阻塞陷入睡眠状态，直到该资源被之前的线程解锁释放，才会唤醒，获得资源的使用权，并加锁。如果被阻塞的线程不止一个，他们将都会被唤醒，但获得资源的使用权的只有一个，其他将会再次进入沉睡；

使用场景：共享数据操作的完整性，场景大多是写大于读的操作；

## 递归锁/可重入锁

同一个线程将一个资源加锁多次，其他线程必须等待资源的所有锁释放后才可获得使用权；

递归锁必须保证加锁的次数和解锁的次数相同，不然会出现死锁情况；

同一个线程在获取的资源使用权并加锁后可再次对资源加锁，不会因为资源被锁未释放二阻塞，前提是加锁的该线程和对该资源已加锁的线程是同一线程；

实现原理：加锁时，需要判断锁是否已经被获取。如果已经被获取，则判断获取锁的线程是否是当前线程。如果是当前线程，则给获取次数加1。如果不是当前线程，则需要等待。释放锁时，需要给锁的获取次数减1，然后判断，次数是否为0了。如果次数为0了，则需要调用锁的唤醒方法，让锁上阻塞的其他线程得到执行的机会。

使用场景：

## 悲观锁

在关系数据库中，对数据修改持悲观态度，认为在修改时一定存在并发问题，所以要锁起来；

悲观锁表示如果一个事务执行操作(读写)应用了锁，那么只有这个操作提交后，其他的事务才能够执行写操作，否则只能进行读操作；

mysql InnoDB中使用：开启mysql排他锁实现悲观锁；

````
bengin\hegin work\start transaction;(三选一都行)
select * from table where id = 1 for update; // 此时ID=1的数据将被锁住，ID必须要时主键
update table set status=1 where id=1; // 修改数据
commit/commit work;// 提交修改
````

select...for update开启数据排他锁，innoDB默认是行级锁，行级锁是基于索引的，如果sql中不使用到索引将会锁住整张表；

使用场景：用于数据争用激烈，和避免并发产生冲突时使用锁保护数据的成本低于数据回滚的成本的环境中；

## 乐观锁

在关系数据库中，乐观锁表示执行操作(读写)前，仅对数据当前状态数据设置一个版本，然后操作数据，在提交的时候对比数据版本是否相同，如果相同则提交，如果不同则表示该数据已不是操作前的原数据，被其他修改过。则无法提交；

实现数据版本有两种方式：

一：使用版本号

​	在数据中加一个版本字段，每次操作前字段+1操作，记录新的版本号，在后面提交时判断版本号是否相同；

二：使用时间戳

​	数据库中加上当前时间戳，每次操作前记录存入的时间戳，在后面提交时对比操作中记录的时间戳和数据库中存入的时间戳是否相同；

## 公平锁

阻塞队列在可获取锁时候的顺序；先到的线程将会优先获取到锁；

## 非公平锁

阻塞队列在可获取锁的时，优先获取的是唤醒的线程。如果线程在阻塞中，刚好之前的线程执行完成释放了锁，触发唤醒阻塞中的线程，这个唤醒动作中有不少上下文切换开销，可能刚好进来一个线程需要锁，这个线程将会在队列中其他线程被唤醒前获取到锁；所以这个获取到锁的顺序就是和公平锁的区别；

非公平锁效率高于公平锁：因为非公平锁后来的线程可能避免了被阻塞挂起；公平锁后来的肯定会被阻塞挂起；

## 独享锁

资源每次只能被一个线程所持有

## 共享锁

该锁可以被多个线程共有

## 读写锁

有 读状态加锁、写状态加锁、不加锁三种状态

当一个线程对资源拥有写锁时，其他线程将无法获取该资源的写锁、读锁，

当一个线程对资源拥有读锁时，其他线程可以获得该资源的读锁，但无法获取其写锁，想获取写锁的线程将进入阻塞挂起状态；

使用场景：读操作大于写操作。写则可以互斥，只能有一个些者可以写。写者优先于读者，当有写着时读者必须等待中；

## 分段锁

将需要加锁的资源分段成N个独立的资源块。每一块添加一个独立的锁。

提高了并发性能

## 自旋锁 

自旋锁是一种特殊的互斥锁，当想在已经加锁的资源上获取锁时，互斥锁会进入阻塞挂起状态，自旋锁则会进入循环等待状态，不会被挂起，会一直循环尝试获取锁，直到获取到锁。这样减少了资源从睡眠到唤起的资源消耗。但会一直占用CPU资源。适用于资源被锁的持续时间短，不希望在线程上唤醒花开销的情况，保护一段段小的临界区(获取锁到释放锁中间代码执行区块)操作代码。

## 偏向锁/轻量级锁/重量级锁



## 减少锁的竞争程度：

* 减少锁的持有时间；
* 降低锁的请求频率；
* 使用带有协调机制的独占锁，这些机制允许更高的并发性；