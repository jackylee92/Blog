# 第一章

> 本章主要讲MySQL的设计架构，和架构中比较重要的模块作用和简单介绍，还有一些发展史。

## 逻辑架构

__第一层：__

负责MySQL客户端连接时的认证、线程处理、安全等相关；

__第二层：__

绝大多数MySQL的核心服务（查询解析、分析、优化、缓存、内置函数、存储过程、触发器）；

会解析查询，优化、重写查询、决定表的读取顺序，以及选择合适的索引等。

__第三层：__

存储引擎，存储数据，提供给上层服务API，响应上层服务请求；

## 并发控制

__方式：__

读写锁：读锁是共享的，互相不阻塞，也就是说多个用户可以同时回去一个资源的读锁而互不影响。写锁是排他的，也就是说，一个写锁会阻塞其他用户获取写锁和读锁。

__颗粒度：__

表锁：对整张表加锁，开销比较小。当在对表进行些操作时，需要先获取表的写锁，获得写锁后会阻塞其他用户对该表的搜索操作。

行锁：最大程度的支持并发，开销比较大。

## 事务

__特性（ACID）：__

原子性：全部成功/失败。

一致性：事务中的成功失败统一执行。

隔离性：未提交之前对其他事物是不可见的。

持久性：一旦提交，操作的数据将保存如数据库中。

__隔离级别：__

未提交读（READ UNCOMMITTED）：事物中的修改未提交时对其他事物都是可见的【脏读】。实际应用中非常少见。

提交读（READ COMMITTED）：一个事物从开始到提交之前，所做的任何修改对其他事物都是不可见的。

可重复读（REPEATABLE READ）：该级别保证了同一个事物中多次读取同样的记录的结果是一致的。

可串行化（SERIALIZABLE）：最高级别的隔离限制，强制事务以串行之行。避免了幻读、脏读问题，但可能会导致大量的超时和锁竞争的问题。

__死锁：__

两个事务都等待对方释放锁，同时都持有对方需要的锁。

INNODB目前解决方案：将持有最少行级排他锁的事务进行回滚。

__自动提交（AUTOCOMMIT）：__

MySQL默认采用自动提交模式，也就是说，如果不是显式的开始一个事务，则每个查询都会被当作一个事务之行提交操作。

````
// 查看使用的自动提交模式；AUTOCOMMIT=0标示所有的查询都在一个事务中，直到显式的之行COMMIT或者ROLLBACK，事务结束。
SHOW VARIABLES LIKE 'AUTOCOMMIT'	
````

对非事务型的表是无效的。比如MyISAM或者内存表

## 多版本并发控制

乐观/悲观并发控制：通过在每行记录后面保存两个隐藏的列来实现。一个保存了行的创建时间，一个保存行的过期时间。作为数据的版本号，事务开始时记录版本号，在事务结束时对比版本号。

Select：查找删除版本号大于当前事务版本（保证该事务时，该数据未被删除）和未删除的数据版本号早于当前事务版本（保证查到的数据时该版本该之前状态）的数据；

Insert：为新插入的每一行数据保存当前系统版本号作为版本号；

Delete：为删除的每一行数据保存当前系统版本号作为行删除标示；

Update；InnoDB为插入一行新数据，保存当前系统版本号作为行版本号，同时保存但前系统版本号到原来的行作为删除标示；

__保存这两个版本号，使大多数读操作都可以不加锁__

## 存储引擎

### 存储引起介绍

.frm：保存表的定义

````
// 查看表信息
SHOW TABLE STATUS LIKE "tableName"
````

Name：表名

Engine：表的存储引擎

Row_format：行格式

Rows：表中的行数

Avg_row_length：平均每行包含的字节数

Data_length：表数据的大小

Max_data_length：表数据的最大容量，该值和存储引擎有关

Index_length：索引的大小

Data_free：标示已分配但目前未使用的空间

Auto_increment：下一个AUTO_INCREMENT的值

Create_time：表的创建时间

Update_time：表的最后修改时间

Check_time：使用CHECK TABLE命令或者Myisamchk工具左后一次检查表的时间

Collation：表的默认字符集和字符列排序规则

Checksum：如果启用，保存的事整个表的实施校验和

Create_options：创建表时制定的其他选项

Comment：包含一些其他额外信息

* INNODB：

> 它被设计来处理大量的短期事务，短期事务大部分情况可以正常提交，很少出现回滚。INNODB的性能和自动崩溃恢复特性，是他在非事务性存储的需求中也很流行。

采用MVCC来支持高并发。

实现四个标准的隔离级别，默认时REPEATABLE READ(可重复度)，并通过间隙锁策略防止幻读出现。

基于聚簇索引

支持从磁盘读取数据时采用可预测性预读

可自动在内存中创建hash索引以加速读的操作

加速插入操作的插入缓冲区

* MyISAM：

> 提供了大量的特性：全文索引、压缩、空间函数等，但不支持事务和行级锁，且崩溃后无法安全恢复。

会将表存入两个文件中：.MYD、.MYI为扩展名。

__特性：__

加锁与并发：

​	MyISAM会对整张表加锁，而不是针对行。读取时对需要读取的表加共享锁，写入时则对表加排他锁。但时在表有读取查询的同时，也可以忘表中插入新的记录，这被称为并发插入。

修复：

​	执行表的修复可能会导致部分数据丢失。可以通过``CHECK TABLE tableName``检查表的错误，如果有错误可以通过``REPAIR TABLE tableName``修复。

索引：

​	使用BLOB和TEXT等查字段，也可以基于前500个字符创建索引，MyISAM也支持全文索引。这是一种基于分词创建的索引，可以支持复杂的查询，

延迟更新索引：

​	创建MyISAM表时，如果指定了DELAY_KEY_WRITE选项，则在每次修改执行完成时，不会立刻将修改的索引数据写入磁盘，而是会写入到内存中的键缓冲区，只有在清理键缓存区或者关闭表的时候才会将对应的索引块吸入到磁盘中，这种方式极大的提升了写入的性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作，延迟更新索引键的特性，可以在全局设置也可以为单表设置。

__MySIAM压缩表：__

​	对于创建并导入数据后，不会在修改的表适合采用MySIAM压缩表功能。压缩表极大的减少了磁盘的占用，也减少了磁盘的I/O，从而提升了查询的性能，压缩表也支持索引，但索引也是只读的。

​	可以使用Myisampack对MySIAM表进行压缩，也叫打包。

​	如果压缩的表需要修改，则需要先解压缩，然后修改数据，再压缩。解压带来的开销影响并不大，而减少I/O带来的好处则要大的多。

​	压缩表中的记录时独立压缩的，所以读取单行的时候不需要取解压整张表。

__其他存储引擎：__

* Archive

只支持INSERT和SELECT操作。会对所有的数据进行压缩。每次SELECT会进行全表扫描。不支持事务。

* CSV

可以将普通的CSV直接当作MySQL的表来处理。不支持索引。

* Memory

可以快速访问数据，这些数据不会被修改，并且重启后丢失也没关系则可以使用该数据库，所有数据都是存入内存中。没有磁盘I/O消耗。支持Hash索引。支持表级锁，但并发写入的性能较低。不支持BLOB和TEXT类型。每行长度固定，会对varchar自动转为char。

MySQL内部使用的临时表就是Memory，但是如果临时表需要村的数据超过Memory表的限制，或者有BLOB或者TEXT自动，则会转成MyISAM表。

* infobright

最有名的面相列的存储引擎，在非常大的数据量(数十TB)时，工作良好。不支持索引。

### 选择合适的存储引擎

__大多数情况下INNODB都是合适的选择__

* 事务支持
* INNODB支持热备份
* 崩溃恢复
* 索引使用聚簇索引

数据量增长到10TB以上的级别，可能就需要建立数据仓库。Infobright是MySQL数据仓库最成功的解决方案。

### 修改表的引擎

````
ALTER TABLE tableName ENGINE = InnoDB;
````

执行时间会很长：会将原表复制到一张新的表中，同时会为原表加锁，

导入导出方案：

​	将原表使用Mysql Dump导出，修改导出文件中表结构设置，和表名，删除文件中删除原表的语句。会丢失最后一部分数据。

create和select方案：

````
CREATE TABLE tableName;
ALTER TABLE tableName ENGINE=InnoDB;
INSERT INTO tableName SELECT * FROM 原表;
````

数据量不大会和快，数据量大的话考虑分批处理