# 第五章

> 本章极少创建高性能索引

## 索引基础

* 通过索引确定行，然后获取行数据。
* 多列索引的顺序十分重要，因为MySQL只能高效的使用索引的最左前缀列。

### 索引类型

MySQL中索引是在存储引擎层实现的，不同的存储引擎实现方案不同，所以并没有统一的索引标准。

MySIAM使用前缀压缩技术，使得索引更小，但BINNODB使用原数据格式进行存储。

MySIAM索引通过数据的物理位置引用被索引的行，INNODB则根据主键引用被索引的行。

B-Tree通常意味着所有的值都是按照顺序存储，并且每一个叶子页面到根的距离相同。

B-Tree索引的存储引擎不在进行全表扫描，而是从根节点开始进行搜索，根节点的槽中存放了指向子节点的指针，存储引擎根据这些指针向下层找，通过比较节点页面的值和要查找的值可以找到合适的指针进入下层子节点，这些指针实际上定义了子节点页中的值的上下限，最终存储引擎要么找到符合条件的叶子节点，最终的叶子指向被索引的数据，没找到叶子节点该记录不存在。

B-Tree对索引是顺序组织存储的，所以很合适查找范围数据。

组合索引，如果不是按照索引最左列开始查找，则无法使用索引。

组合索引中不可以跳过列索引，就是条件中使用第一列索引后不可以直接使用第三列索引，这样情况下只有第一列索引生效。

组合索引的如果其中某一列有范围查询，则该列右边也就是后面的索引列都将无效。

Hash索引：基于Hash表实现的，对于每一行索引都会建立一个Hash值，每个Hash值对应的保存了指向数据行的指针。

Hash碰撞：Hash表计算的值出现重复。一个Hash值指向多个列，则就要对碰撞的列循环进行后面的条件筛选

| 槽(Slot) | 值(Value)       |
| -------- | --------------- |
| 2323     | 指向第1行的指针 |
| 2324     | 指向第2行的指针 |
| 2325     | 指向第3行的指针 |

每个槽都是顺序的，但是数据行不是。

Hash索引结构十分紧凑，也是顺序，所以定位非常快，查询非常快速。

Hash缺点：

​	索引中存储的是索引Hash值和指向数据的指针，并没有数据中任何值，所以不可以从所以中获取任何数据，只能定位到位置后从磁盘中获取需要的值。

​	Hash索引并不是按照索引的值进行排序而是按照值的Hash值排序存储的。所以也就无法用于排序。

​	组合索引的Hash值不能按照其中一列进行索引，因为Hash值是根据整个整个索引的值生成的。

​	Hash只支持等值比较查询，包括 = 、IN()、<=>。不支持<、>等范围查询。

INNODB引擎注意到某些索引被使用的非常频繁，它会自动、自主的在内存中基于B-Tree上再建立一个Hash索引，这是INNODB的“自适应哈希索引”。

全文索引对比值中的关键词。


## 索引的优点

1. 大大减少服务器需要扫描的数据量
2. 帮助服务器避免排序和临时表建立
3. 将随机I/O变成顺序I/O

## 高新能的索引策略

* 独立的列

  指不能是表达式的一部分，也不能是函数的参数。

* 前缀索引

  对于比较长的字符串索引选择合适长度的前缀索引

* 选择合适顺序的组合索引

  选择性最高的列放在前面通常最佳。

### 聚簇索引

一种索引的存储方式，将数据实际存放在索引的叶子页中。

如果没有定义主键，INNODB会选择一个唯一的非空索引代替，如果没有这样的索引，INNODB会隐式的定义一个主键来作为聚簇索引。

优点：

​	可以把相关数据保存在一起。

​	数据访问速度更快。

​	使用覆盖索引扫描的查询可以直接使用页节点中的主键值。

缺点：

​	插入以来插入的顺序，如果可以最好按照主键顺序插入。

​	更新聚簇索引的代价很高，会对索引重排。

​	基于聚簇索引的表插入行，可能会产生“页分裂”，当要求在一个已满的页中，存储引擎就会将该页分类两个页面来容纳数据，这样会导致占用的空间更多。

​	二级索引（非聚簇索引）可能比想象的大，因为二级索引的叶子节点包含了引用的主键列。

​	二级索引访问需要查询两次，因为二级索引的叶子节点保存的是主键的值。所以其他数据需要再次通过主键索引查找。

使用UUID作为聚簇索引的情况非常糟，它会使聚簇索引插入变得完全随机，没有顺序可言。

### 索引覆盖

如果索引的叶子节点中包含了索引需要查询的字段，则不需要在去表中查询(回表)。我们称这为“索引覆盖”。

减少了数据访问量。

索引存入内存中，查询数据会快很多。

如果查询使用到二级索引，查询的字段为二级索引和主键索引，这也是索引覆盖，因为不需要再去聚簇索引中二次查询。

当使用了索引覆盖 通过Explain中可Extra为`Useing index`

当使用了索引顺序扫描做排序，通过Explain中Type为`inde`可以看到，不要与`Extra`弄混淆

如果查询需要关联多张表，则只有当`Order By`语句的字段全部都是第一张表时，才能使用索引排序，并且同样需要满足最左原则。

### 索引压缩

MyISAM使用前缀压缩来减少索引的大小。从而让更多索引放入内存中。方法是：先完全保存索引快中的第一个值，然后将其他值和第一个值进行比较，得到相同的前缀的字节数和生育的不同后缀部分，把这部分存储起来即可。查询中每个值都依赖前一个值，这样无法使用二分法，并且如果是倒叙就没有优势。

__应该避免重复索引__

### 索引和锁

索引可以是查询锁定更少的行，

### 优化排序

使用延迟查询的方式提高查询效率，先通过索引查询出需要的主键ID，再通过主键ID直接查询出需要的数据。

## 维护索引和表

目的：

1. 找到并修复损坏的表
2. 维护准确的索引信息
3. 减少碎片

* 损坏表会导致MyISAM表崩溃，查询数据错误

INNODB的修复方式

```mysql
ALTER TABLE tableName ENGINE=INNODB;
```

碎片有三类：

行碎片：指数据行被存储在多个地方的多个片段中，即使查询只是从中访问一行记录，行碎片也会导致性能下降。

行间碎片：指逻辑上顺序的也，或者行在磁盘上不是顺序存储的，行间碎片对诸如全表扫描和聚簇索引扫描之类的操作有很大的影响，因为这些操作原本能够从磁盘上顺序存储的数据中获益

剩余空间碎片：指数据页中有大量的空余空间，这会导致服务器读区大量不需要的数据，从而造成浪费。

修复

```mysql
ALTER TABLE <table> ENGINE=<engine>;
```

