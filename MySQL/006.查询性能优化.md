# 第六章

> 本章介绍查询性能优化

## 为什么查询会慢

查询的生命周期大致可以按照顺序来看：从客户端，到服务器，然后在服务器上解析，生成执行计划，执行，返回结果给客户端。

## 优化数据访问

* 查询性能低下最基本的远影是访问的数据太多了，从一下两个方面分析

  1. 确认应用程序是否在检索大量超过需要的数据。
  2. 确认MySQL服务器层是否在分析大量超过需要的数据行。

* MySQL是否扫描了额外的记录，衡量查询开销的三个指标如下

  1. 响应时间
  2. 扫描的行树
  3. 返回的行树

  分析扫描的行数是非常有帮助的，理想情况下扫描的行数和返回的行树应该是相同的。

  通过`Explain`语句中的type可以反应出访问类型：全表扫描、索引扫描、范围扫描、唯一索引扫描、常数应用。这些速度是从快到慢的。

  Explain：

  ​	select_type：

  ​	table：表名

  ​	type：访问类型(全表扫描、索引扫描、范围扫描、唯一索引扫描、常数引用等)

  ​	possible_keys：

  ​	key：

  ​	ken_len：

  ​	ref：

  ​	rows：扫描的行数

  ​	Extra：

  

  MySQL使用一下三种方式应用where中的条件，从好到坏依次为：

  * 在索引中使用WHERE条件来过滤不匹配的记录，这是存储引擎层完成的。
  * 使用索引覆盖扫描(在Extra列出现`Using index`)来返回结果，直接从索引总过滤不需要的记录并返回命中的结果。这是在MySQL的服务器层完成的，但无须在回表查询。
  * 从数据表中返回结果数据，然后过滤不满足条件的记录(在Extra列中出现Using Where)，这是在MySQL服务器层完成的，MySQL需要先从数据表中读取出记录，然后过滤。

  优化方案：

  * 使用索引覆盖，把所有需要用的数据列都放到索引中，这样存储引擎无需回表读取对应的行就可以返回结果了。
  * 重构查询方式

## 重构查询方式

* 将一个复杂的查询切割成多个简单查询

* 将一个涉及大量数据的操作切割成多个简单的操作

  一个大的语句一次性完成的话，则可能需要一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但很重要的查询。切割成小的SQL执行，可以尽可能小的影响MySQL性能，同时还可以减少MySQL复制的延迟。一次操作后最好暂停一会，这样可以将上一次资源释放，恢复服务器的性能，减少操作的锁的持有时间。

* 分解关联查询的方式重构插叙。

## 查询执行的基础

### 执行步骤

1. 客户端发送一条查询个服务器
2. 服务器先检查缓存，如果命中了缓存，则立刻返回存储在缓存中的结果，否则进入下一个阶段
3. 服务器端进行SQL解析、预处理、在由优化器生成对应的执行计划
4. MySQL更具优化器生成的执行接话，调用存储引擎的API来执行查询
5. 返回数据给客户端

#### MySQL客户端/服务器通信

通讯协议是半双工，在任何一个时刻，要么有服务器向客户端发送数据，要么是客户端向服务器发送数据，这两个动作不能同时进行。这种通行简单快速，但是限制了MySQL，没法进行流量控制，一旦一端开始发送消息，另一端智能是等待接受完成才能响应它。客户端向MySQL去数据时，其实是MySQL向客户端推送数据，客户端不断的接受从服务器推送的数据，客户端也无法让服务器停下来，所以最好使用LIMIT控制数据量。

以下mysql_query已经从MySQL服务器中获取到所有的结果，存入内存中，通过`while`循环逐条获取；

如果查询的数据量特别大，会占用非常多的内存空间。

```php
<?php
$link = mysql_connect('localhost', 'user', 'password');
$result = mysql_query('SELECT * FROM user', $link);
while( $row = mysql_fetch_array($result) ) {
  // Do something with result
}
?>
```

以下是不使用缓存

```php
<?php
$link = mysql_connect('localhost', 'user', 'password');
$result = mysql_unbuffered_query('SELECT * FROM user', $link);
while( $row = mysql_fetch_array($result) ) {
  // Do something with result
}
?>
```

#### 查询缓存

在解析一个查询语句之前，如果查询缓存是打开的，MySQL会优先检查这个查询是否会中查询缓存中的数据，查询和缓存中的查询即使又一个字节不同，也不会匹配缓存结果。

#### 查询优化

查询缓存下一步是将一个SQL转换成一个执行计划，MySQL在依照这个执行计划与存储引擎交互。这个转换过程包括：解析SQL、预处理、优化SQL执行顺序

__语法解析器和预处理__

首先MySQL通过关键字将SQL语句进行解析，并生成一个对应的解析书，MySQL解析器将使用MySQL语法规则验证和解析查询。关键字解析就是验证关键字使用十分正确。预处理就是检查SQL是否合法，表、字段是否在、权限等。

__查询优化器__

通过预处理确认SQL是合法的。下一步就是有优化器生成执行计划，一条SQL会有很多种执行方式，优化器的作用就是确定其中最好的执行方式。优化器选择的方案并不一定也是你认为最优的方案，优化器以来存储引擎提供的统计信息来评估成品，会存在误差。优化器对成本的评估纬度和你的维度可能不同，优化器可能选择执行时间最快，你可能需要占用内存最低的方案。

##### 优化器的优化类型有：

* 重新定义关联表的顺序

  数据的关联并不是总按照在查询中指定的顺序，决定关联的顺序是优化器，

* 将外部连接转化为内链接

  并不是所有的OUTR JOIN语句都必须以外连接的方式执行，诸多元素，例如WHERE条件、库表结构都可能会让一个外连接等价于一个内连接。

* 使用等价变换规则

  MySQL可以使用一些等价变化来简化并规范表达式。使它可以合并、减少一些比较，还可以一出一些恒定和一些恒不成立的判断。

* 优化COUNT(*)、MIN()和MAX()

  索引和列是否可以为空通常可以帮助MySQL优化这列表达式。例如找到一列的最小值，只需要查询对应B-Tree索引最左端的记录，MySQL可以直接获取索引的第一行。

* 语句并转化为常数表达式

  当MySQL检测到一个表达式可以转化为常数时，就会一直把该表达式作为常数进行优化处理。

* 索引覆盖扫描

  MySQL索引中的列宝行了所有查询中需要使用的列的时候，MySQL就可以直接使用索引返回需要的数据，而无需查询对应的数据。

* 子查询优化

  MySQ在某些情况下可以将子查询转换一种效率更高的形式，从而减少多个查询多次对数据进行访问。

* 提前终止查询

  在发现已经满足需求的时候，MySQL总是能够立刻终止查询。

* 等值传播

  如果另个列的值通过等式关联，那么MySQL能够把其中一个列的WHERE条件传递到另一列上。

#### 关联查询

对于UNION查询，MySQL先将一些列的单个查询结果放在一个临时表中，然后在重新读取出临时表数据来完成UNION查询。

策略：MySQL对于任何关联都执行嵌套循环关联操作，即MySQL先在一个表中取出单条数据，然后在嵌套循环到下一个表中找匹配的行，依次下去，知道找到所有的表中匹配的行为止，然后根据各个表匹配行，返回查询中需要的列，MySQL会尝试在最后一个关联中找出所有匹配的行，如果最后一个关联表无法找出更多的行以后，MySQL返回到上一层关联表，看是否能够找到更多匹配记录，依此类推迭代执行。

#### 执行计划

MySQL会生成一个指令树，然后通过存储引擎执行完这个指令树并返回结果。

#### 关联查询优化器

通过评估不同顺序的成本来选择一个代价最小的关联顺序。例如：INNER JOIN 会选择扫描最少行的表作为第一张表。

#### 排序优化

排序是一个成本很高的操作，MySQL可以通过索引进行排序，当不能使用索引生成排序结果时，MySQL需要自己进行排序，如果数据量洗哦啊则在内存中排序，如果数据量大，则需要使用磁盘，MySQL对于小于排序缓冲区的数据，在内存中进行“快速排序”。

#### 返回结果

如果查询可以缓存，MySQL在这个阶段会将结果存放在查询缓存中，一旦服务器处理完最后一个关联查询，开始生产第一条结果时，MySQL就可以开始向客户端逐步返回结果了。这样1:服务器端无需存储太多数据 2:MySQL客户端可以更快的获取到结果。

## 查询优化器的局限性

### 关联子查询

MySQL对于WHERE条件中包含IN()的子查询处理的非常糟糕，例如以下

```mysql
SELECT * FROM A WHERE A.a_id IN (
  SELECT B.id FROM B WHERE b.a_od = 1
)
```

我们正常会认为MySQL 会先执行B表的查询，然后再执行A表的查询。实际上MySQL会对A表全表扫描，然后逐个执行子查询，上面的查询可以优化：

```mysql
SELECT A.* FROM A INNER JOIN B USING(a_id) WHERE a_id = 1;
```

### 不允许再同一张表上查询和更新

MySQL不允许再同一张表上同时更新和查询

```mysql
UPDATE A AS OutTable SET fieldName = (
	SELECT count(*) FROM A as InnerTable WHERE InnerTale.type = OutTable.type 
);
```

可以通过生成临时表方式绕过上面限制

```mysql
UPDATE A INNER JOIN (
	SELECT type, count(*) as cnt FROM A GROUP By type
) AS der USING(type) 
SET a.cnt = der.cnt;
```

## 优化特定类型的查询

### `COUNT(*)`

COUNT(*)聚合函数，可以统计某列的数量(不统计NULL)，也可以统计行数，

最简单的就是我们使用`COUNT(*)`的时候，他会忽略所有的列而直接统计所有的行数，

### 优化子查询

子查询优化方案是尽量使用关联查询代替，因为子查询会先执行外面查询，然后遍历外面结果关联里面查询，

### 延迟关联

获取需要的访问记录后再根据关联列回原表查询需要的所有列

```mysql
SELECT film_id, description FROM sakila.film ORDER BY title LIMIT 50, 5;
```

使用延迟关联后：

```mysql
SELECT film.film_id, film.description FROM sakila.film INNER JOIN (
	SELECT film_id FROM sakila.film ORDER BY title LIMIT 50, 5
) AS lim USING(film_id)
```

### LIMIT OFFSET

当OFFSET过大时，会导致扫描大量不需要的行，然后抛弃，优化方案是记录上次取数据的位置，那么下次就可以直接从该位置开始扫描

