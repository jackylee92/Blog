# 第四章

> 本章介绍架构与数据类型优化

## 优化数据类型

### 更小的通常更好

更小的数据类型通常更快，因为它占用更少的磁盘，内存，CUP缓存，并处理时需要的CPU周期也更少。

### 简单更好

简单的数据类型的操作通常需要更少的CPU周期。例如，整形比字符型操作代价更低。因为字符集和校对规则(排序规则)，时字符比较比整形比较更复杂。

### 尽量避免使用NULL

通常情况下最好指定为`NOT NULL`，除非真的需要。包含NULL的列对MqSQL更难优化，因为可为NULL的列是的索引、索引统计和值比较都更复杂。可为NULL的列会使用更多的存储空间，在MySQL中也需要特殊处理。当可为NULL的列被索引时，每个索引记录需要一个额外的字节，在MyISAM中甚至还可能导致固定大小的索引变成可变大小索引。

### 类型

* 整数类型

  TINYINT，8位存储空间，SMALLINT，16位存储空间，MEDIUMINT，24位存储空间，INT，32位存储空间，BIGINT，64为存储空间。

  UNSIGNED：标示不允许负值，可使正数范围上限提高一倍。

  MySQL可以为整数指定宽度，例如INT(11)，对于大多数应用这是没有意义的，他不会限制值的合法范围，只是规定了MySQL的一些交互工具(例如MySQL命令行客户端)来限制字符个数，对赖存储和计算来说INT(11)和INT(20)是相同的。

* 实数类型

  实数是带有小数部分的数字。DECIMAL类型用于存储精准的小数，浮点和DECIMAL类型都可以指定精度，即可以指定小数点前后多少位长度。因为CPU不支持对DECIMAL的直接计算，所以在MySQL5.0以及更高的版本中MySQL服务器自身实现了DECIMAL的高精度计算，相对而言，CPU直接支持原生浮点计算，所以浮点运算更快。

* 字符串类型

  VARCHAR类型用于存储可变长度字符串，是最常用的字符串数据类型，它比定长类型更节省空间，因为他仅使用必要的空间（越短的字符串使用的空间越少），有一种情况例外，MySQL表使用`ROW_FORMAT=FIXED`创建的话，每一行都会使用定长存储，VARCHAR需要使用1或者2个额外字节记录字符串长度，

  CHAR类型是定长的，MySQL根据定长的字符串长度分配足够的空间，当存储CHAR值是，MySQL会删除所有的末尾字符，CAHR会根据需要采用空格进行填充一方便比较，这个应该是在存储的时候占用固定长度空间，对于不超过固定长度CHAR会将末尾空格删除，CHAR适合存储很短的值，或者所有的值的长度都接近。对于经常变更的数据，CHAR比VARCHAR更好，因为定长的CHAR类型不容易产生碎片。对于短的列，CHAR比VARCHAR在存储空间上也更有效，因为VARCHAR需要一个额外的字节记录长度。

  VARCHAR(5)和VARCHAR(200)对于存储一个长度为5的值，磁盘空间开销是一样的。但是处理时VARCHAR(200)会消耗更多的内存。尤其使用到内存临时表示，也会占用更多的空间。

* BLOB和TEXT类型

  都是为了存储很大的数据，分别采用二进制和字符串方式存储。分别有字符型：TINYTEXT、SMALLTEXT、TEXT、MEDIUMTEXT、LONGTEXT，二进制：TINYBLOB、SMALLBLOB、BLOB、MEDIUMBLOB、LONGBLOB。

  BLOB类型存储的是二进制数据，没有排序规则或字符集，TEXT类型有字符集和排序规则。排序只会对每列最前`max_sort_length`字节而不是整个字符串做排序。如果只需要排序前面一小部分，则可以减少`max_sort_length`的配置，或者使用`ORDER BY SUSTRING(column, length)。

  MySQL不能将BLOB和TEXT列全部长度的字符串进行索引，也不能使用这些索引消除排序。

* 枚举类型

  自定义该值所属的范围。MySQL的枚举类型存储是非常紧凑，会将列表值的数值压缩到一个或两个字节中，MySQL在内部会将每个值在列表中的位置存储为整数，，并在表的`.frm`中保存“数字-字符串”的映射关系的“查找表”，枚举类型排序会按照内部存储的数值排序而不是定义的字符串排序。

  最不好的地方还有：添加值的时候必须要ALTER TABLE。
  
* 日期和时间类型

  DATETIME：1001年～9999年，进度为秒，TIMESTAMP：1970年～2038年，精度为秒。

* BIT

  只可以存储一个或多个0或1，当我们使用该值计算时，该值会由二进制转成十进制。（书上说原该值会转成十进制的值在ASCII码对应的字符串，但实际测试中并没有出现，而是打印出原BIT类型值）

  实际生产中最好避免使用该类型。


## 架构中的陷阱

* 太多列

  MySQL的存储引擎API工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后在服务器层将缓冲内容解码成各个列。从行缓冲中将编码过的列转换成行数据结构的操作代价是非常高的。MySQL的定长行结构实际上与服务器层的行结构正好匹配，所以不需要转换。然而变长行则需要转换，转换的代价依赖于列数。

* 太多关联

  如果需要关联，单个表最好在12个表以内做关联。

* 全能的枚举

  防止过度使用枚举

* 变相的枚举

  枚举使用不合理会导致混乱，可读性降低。

## 范式和反范式

* 范式化的更新操作通常比反范式化要快
* 范式化的表通常更小
* 查询语句上可能需要多一次关联查询

## 缓存表和汇总表

建立一些中间表来存储一些简单的可以查询到但很耗时的数据，来实现更快的读。

## 加快Alter Table操作

* 在一台不提供服务的机器上执行`ALTER TABLE`操作，然后和提供的服务进行主机切换。
* 影子拷贝，依据原表结构建立一个和原表无关的新表，通过重命名和删表来执行交换操作。
* 通过`.frm`文件，创建一张有相同结构的空表，执行`FLUSH STATUS WITH READ LOCK`锁住原表。交换`.frm`文件，执行`UNLOCK TABLES`释放原表的锁。

