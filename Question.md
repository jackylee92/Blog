

* goroutine

  go通过语言层面实现了协成，比系统层面的线程更轻量，其实就使goroutine，是程序执行流的最小单位，当启动main函数时就创建了一个主goroutine，同时也可以通过go方法创建更多goroutine，goroutine同样也支持并发，可以运行在多个线程之上，线程连接go的处理器，通过处理器调度goroutine，控制它的运行和等待，这是MPG模型，不同的goroutine之间通过channel来实现通讯。

  使用goroutine的优势是：

  ​	从用户态层面就能控制调度；

  ​	goroutine是属于用户空间的，避免了内核空间和用户空间的切换成本；

  ​	goroutine占用内存非常小，可创建非常多的实例；

* channel

  channel是提供goroutine之间通信的管道，channel分为有缓存和无缓存，当设置了有缓存channel时，缓存中数据满了的情况下，发送方将进入阻塞，直到接收方读取了缓存中数据，发送方才会被唤醒，当缓存为空时，接收方将进入阻塞，直到发送方向channel中传入数据，才会唤醒接收方goroutine。channel内部原理是通过互斥锁来控制缓存中数据的copy，channel在go中是一个结构体，当我们实例化这个结构体时，返回的是这个实例化的指针，channel只关心数据接受和发送，并不关系两边的goroutine，这样两边就实现了结偶

  实际场景中通过channel来实现不同goroutine之间的通信，或者通过channel来控制并发数量；

* 进程：系统分配给独立运行的程序一块资源运行单元；每个进程都有自己的独立内存空间，他们是相互独立的；

* 线程：进程内部程序运行的活动单元，一个进程中可能会有多个线程，线程他们相互独立，共享进程的全部资源（它和系统的内核数量有关），线程上下文切换很快，开销相对较小，但是如果线程挂了，进程也会死掉；

* 协成：是用户态的轻量级线程，协成的调度是有用户空间控制的

* golang锁有哪些

  通过channel实现

  定一个channel，一端接受，处于阻塞状态，通过goroutine实现业务逻辑，在方法执行完向channel中传值

  Mutex锁实现	Lock Unlock

  Redis分布式锁

  waitGroup 控制并发 Add 、 wait、done

* channel有无缓冲区别、原理、使用场景

  channel有缓冲区，推送方在缓冲区满了就会阻塞，接收方在缓存区为空的情况下就会阻塞

  channel无缓冲区，指接收方和推送方没有都准备好时，会阻塞；

  原理：

  channel是由一个buf、sendx、recvx、lock、sendq、recvq等实现的一个结构体；

  buf：存放缓冲的循环列表

  sendx：记录buf中发送方当前发送位置的index

  resvx：记录buf中接收方当前接受的index

  lock：锁，互斥锁

  send：发送的协成队列

  resvq：接受的协成队列

  实例化一个channel的结构体返回的是一个指针类型，

  ````
  ch := make(chan int, 3)
  ````

  实例化一个buf长度为3的channel

  ````
  ch <- 1
  ````

  当向channel中send数据时，会先锁住channel，然后才向channel的buf中copy数据，当buf中数据满了则停止copy

  ````
  <- ch
  ````

  当向channel中接受数据时，同样会先锁住channel，然后从channel的buf中coopy出数据

  buf是个循环链表，会根据sendx、和recvx标示的位置顺序的copy数据，这服务FIFO的原则(first into first out)

  当buf满了后，继续send或者recv就是阻塞，因为goroutine时用户态的协成，通过go调度器使goroutine阻塞，唤醒其他goroutine，同时阻塞的goroutine会抽象成包含它的指针和send元素的sudog结构体保存在sendq中或者recvq中；

* golang 调度器、调度原理，并发原理

  并发：在一段时间内两个任务都执行完成，只关心这段时间内两个任务都完成，不关心任何一个时间点是否两个任务都在执行；

  并行：在一段时间内的任意一个时间点，两个任务都在执行；

  并发包含并行

  __不要以共享内存的形式来通信，要以通信的形式来共享内存；__

  go语言就是通过channel管道来通信实现共享内存；

  无论语言形态何种并发模型，到了操作系统层面都是以线程的形式存在，操作系统根据资源的访问权限不同，体系架构分为__用户空间__和__内核空间__

  __内核空间：__主要操作访问系统层面的资源CPU、IO、内存为上层程序提供最基本的基础资源；

  __用户空间：__上层程序活动的空间，用户空间不可以直接访问系统层面资源，必须调用“系统调用”、“库函数”，“Shell脚本”来调用内核空间提供资源；

* golang协成比线程轻量

  goroutine从用户态就能控制调度；

  goroutine属于用用户空间，避免了内核空间和用户空间的切换成本；

  goroutine占用资源非常小，可以创建很多；

* PHP pcntl异步原理

  通过fock创建子进程，子进程会复制主进程上下文，fock通过返回值不同可以判断当前处于主进程还是子进程；

* IO多路复用

* 用户态：用户程序的活动空间，无法直接操作系统资源。

* 内核态：提供用户态可以访问系统资源的空间

* 用户态->内核态

  1. 用户态将数据存放在寄存器中，或者使用参数创建一个堆栈，里面存放需要操作系统提供的服务
  2. 用户态程序执行陷阱指令
  3. CPU切换到内核态，并跳到内存指定位置的指令，这些指令是操作系统的一部分，属于操作系统，不可被用户态访问；
  4. 陷阱指令会执行用户态是存入内存的数据参数，执行程序的请求服务，
  5. 执行完后，操作系统会充值CPU返回用户态，并返回系统调用结果；

* Golang的内存模型

* Epoll原理

* Golang垃圾回收机制GC

* select{} 使用详细了解

* map使用时除非make否则基本不能使用，都是nil

* defer

  多个defer情况下顺序是先进后出，但会对defer中函数的参数求值，但不会进入函数体，并将函数压入调用栈中

* 用户级线程

  多个用户态的线程对应一个内核线程，M：1，程序线程的创建、终止、切换或者同步等线程工作必须由自身完成

* 内核级线程

  多个用户态的线程对应多个内核态线程，1:1，直接调用操作系统的内核线程，所有线程的创建、终止、切换同步工作由内核来完成。C++就是这种

* 双级线程模型

  一个京城中可以对应多个内核级线程，但是进程中的线程不和内核线程一一对应；这种线程模型会先创建多个内核级线程，然后用自身的用户级线程去对应创建的多个内核级线程；

* redis原理 结构 每种使用场景

* 数据结构、算法

* php标准库

* linux

* 字节跳动

* haspmap数据结构

* http三次握手 7层结构

* mysql索引结构 原理

* 二叉树

  树状的数据结构，结点顺序都是左边小于右边；

  缺点是：如果是自增ID，或变成右边链表结构；

* 红黑树

  基于二叉树，如果二叉树出现了不平衡情况，则会自动旋转调整结点的位置，如果是自增ID的情况下，同样会出现右边偏重的情况，如果数据量非常大，树的高度也很大

  缺点是：自增ID的情况下同样会出现右倾，让树的高度特别大

* B树

  基于多路平衡查找树，每个节点存放多个索引和数据，数据可能是符合条件的完整数据或者是指向数据的地址指针。

  缺点是每个节点存放的索引没有B+树多，并且叶子结点也不是顺序的双向列表；

* B+树

  基于B树，不同的是每个节点中仅保存16大小的索引，叶子结点里面顺序保存了所有的索引和对应的数据（数据可能是符合条件的完整数据，或者是执行符合条件的数据地址的指针）；

* B树和B+树的区别是：

  B树节点中保存的是索引和数据，B+树中保存的是索引，所以节点中B+树可以保存非常多的索引，降低了树的高度

  B+树叶子结点是一个双向链表，便于范围查询，B树则不是

* hash

  mysql的Hash是，对索引进行hash函数得到一个值，这个值在一张hash表中对应的存放着这个索引的数据，

  缺点是没办法进行范围查询，精确查询的效率非常高

  会出现hash碰撞，出现的话会将原索引与查询到的数据逐一对比，影响IO性能

* 聚集索引

  INNODB就是聚集索引，他是在B+树的叶子结点存放了对应的数据，当查到符合条件的索引时就可以直接取出数据；

* 非聚集索引

  MYISAM就是非聚集索引，他在叶子结点存放的是对应的数据的地址指针，当查到符合条件的索引时通过对应的指针定位数据位置；

* 回表

  回表

* 覆盖索引

* INNODB必填有主键，并且最好时自增ID

  首先INNODB是必须要有主键的，因为B+树就是基于组件形成的。如果没有建立主键，INNODB会挑选第一个唯一键作为主键，如果没有唯一键，则会隐形生成一个主键；自增ID的主键能在叶子结点更好向后叠加。如果不是自增则可能产生B+树的结构调整，影响性能；

* 什么情况下没有使用到索引

  使用不等于的情况下

  使用like并且左边是通配符

  当mysql分析后认为全表查询比索引查询更快时

  查询中使用了计算或者函数

  当使用联合索引,前面一个条件为范围查询,后面的即使符合最左前缀原则,也无法使用索引.？

* 什么是存储过程？有哪些优缺点？

* 执行流程

* 事务

**第一部分：****通用模块。**此部分对 MySQL 整体概念、执行流程、数据库引擎、查询缓存、表空间、回表查询、数据类型间的区别、内存表、临时表、删除表的 n 种方式、枚举、视图、数据恢复等相关知识点对应的面试题进行解答。

**第二部分：****索引模块。**索引的好坏直接影响数据库的性能，所以索引的面试题也是面试中必问的问题，此部分为索引对应的面试题合集。

**第三部分：事务模块。**事务决定了程序的稳定性，在 MySQL 中的地位也是首屈一指，也是面试中必问的面试题，此部分为事务对应的面试题合集。

**第四部分：锁。**锁包括：全局锁、表锁、行锁、死锁、乐观锁、悲观锁等，不同的数据库引擎支持的锁支持粒度也是不同的，此部分的面试题，让你彻底搞定锁相关的面试题。

**第五部分：日志。**日志看似不起眼，却是 MySQL 主备同步和容灾恢复以及问题排除的关键，当然也是面试中必问的问题，这部分会对不同的数据库引擎中的重点日志，进行详细的介绍。

**第六部分：MySQL 操作命令和内置函数。**MySQL 的操作命令，对于程序员或者 DBA 来说也是必须具备的一项技能，比如，用户和权限的创建、数据库相关信息的查询等，都离不开对 MySQL 命令行的掌握。对内置函数的掌握程度，代表了你对 MySQL 的掌握程度，善用 MySQL 提供的内置函数，会让你有事半功倍的效果，内置函数也是笔试中必考的面试题。

**第七部分：性能优化和分布式。**性能优化和分布式是面试中决定你高度的关键指标，其中性能优化包括了慢查询的分析和处理，对分布式的掌握体现了你的技术深度。

**第八部分：开放性问题。**很多大公司最后也会问一下没有标准答案的开放性问题，以考察面试者的技术能力边界和对待问题的分析思路，这部分助你更平稳的获得 offer。